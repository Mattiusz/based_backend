// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: events.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    creator_id, name, location, datetime, 
    max_attendees, venue, description, age_range_min, age_range_max,
    allow_female, allow_male, allow_diverse, thumbnail, status, categories
)
VALUES (
    $1, $2, ST_SetSRID(ST_MakePoint($4, $3), 4326), $5, 
    $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
)
RETURNING 
    event_id,
    created_at,
    updated_at,
    creator_id,
    name,
    ST_Y(location::geometry) as latitude,
    ST_X(location::geometry) as longitude,
    datetime,
    max_attendees,
    venue,
    description,
    status,
    age_range_min,
    age_range_max,
    allow_female,
    allow_male,
    allow_diverse,
    thumbnail,
    status,
    categories
`

type CreateEventParams struct {
	CreatorID     pgtype.UUID         `json:"creator_id"`
	Name          string              `json:"name"`
	StMakepoint   interface{}         `json:"st_makepoint"`
	StMakepoint_2 interface{}         `json:"st_makepoint_2"`
	Datetime      pgtype.Timestamptz  `json:"datetime"`
	MaxAttendees  int32               `json:"max_attendees"`
	Venue         pgtype.Text         `json:"venue"`
	Description   pgtype.Text         `json:"description"`
	AgeRangeMin   pgtype.Int4         `json:"age_range_min"`
	AgeRangeMax   pgtype.Int4         `json:"age_range_max"`
	AllowFemale   bool                `json:"allow_female"`
	AllowMale     bool                `json:"allow_male"`
	AllowDiverse  bool                `json:"allow_diverse"`
	Thumbnail     []byte              `json:"thumbnail"`
	Status        EventStatusType     `json:"status"`
	Categories    []EventCategoryType `json:"categories"`
}

type CreateEventRow struct {
	EventID      pgtype.UUID         `json:"event_id"`
	CreatedAt    pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz  `json:"updated_at"`
	CreatorID    pgtype.UUID         `json:"creator_id"`
	Name         string              `json:"name"`
	Latitude     interface{}         `json:"latitude"`
	Longitude    interface{}         `json:"longitude"`
	Datetime     pgtype.Timestamptz  `json:"datetime"`
	MaxAttendees int32               `json:"max_attendees"`
	Venue        pgtype.Text         `json:"venue"`
	Description  pgtype.Text         `json:"description"`
	Status       EventStatusType     `json:"status"`
	AgeRangeMin  pgtype.Int4         `json:"age_range_min"`
	AgeRangeMax  pgtype.Int4         `json:"age_range_max"`
	AllowFemale  bool                `json:"allow_female"`
	AllowMale    bool                `json:"allow_male"`
	AllowDiverse bool                `json:"allow_diverse"`
	Thumbnail    []byte              `json:"thumbnail"`
	Status_2     EventStatusType     `json:"status_2"`
	Categories   []EventCategoryType `json:"categories"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (CreateEventRow, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.CreatorID,
		arg.Name,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.Datetime,
		arg.MaxAttendees,
		arg.Venue,
		arg.Description,
		arg.AgeRangeMin,
		arg.AgeRangeMax,
		arg.AllowFemale,
		arg.AllowMale,
		arg.AllowDiverse,
		arg.Thumbnail,
		arg.Status,
		arg.Categories,
	)
	var i CreateEventRow
	err := row.Scan(
		&i.EventID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatorID,
		&i.Name,
		&i.Latitude,
		&i.Longitude,
		&i.Datetime,
		&i.MaxAttendees,
		&i.Venue,
		&i.Description,
		&i.Status,
		&i.AgeRangeMin,
		&i.AgeRangeMax,
		&i.AllowFemale,
		&i.AllowMale,
		&i.AllowDiverse,
		&i.Thumbnail,
		&i.Status_2,
		&i.Categories,
	)
	return i, err
}

const getEventAttendeeStats = `-- name: GetEventAttendeeStats :one
SELECT 
    COUNT(CASE WHEN gender = 'female' THEN 1 END) as female_count,
    COUNT(CASE WHEN gender = 'male' THEN 1 END) as male_count,
    COUNT(CASE WHEN gender = 'diverse' THEN 1 END) as diverse_count
FROM event_attendees
WHERE event_id = $1
`

type GetEventAttendeeStatsRow struct {
	FemaleCount  int64 `json:"female_count"`
	MaleCount    int64 `json:"male_count"`
	DiverseCount int64 `json:"diverse_count"`
}

func (q *Queries) GetEventAttendeeStats(ctx context.Context, eventID pgtype.UUID) (GetEventAttendeeStatsRow, error) {
	row := q.db.QueryRow(ctx, getEventAttendeeStats, eventID)
	var i GetEventAttendeeStatsRow
	err := row.Scan(&i.FemaleCount, &i.MaleCount, &i.DiverseCount)
	return i, err
}

const getEventByID = `-- name: GetEventByID :one
SELECT 
    e.event_id,
    e.created_at,
    e.updated_at,
    e.creator_id,
    e.name,
    ST_Y(e.location::geometry) as latitude,
    ST_X(e.location::geometry) as longitude,
    e.datetime,
    e.max_attendees,
    e.venue,
    e.description,
    e.status,
    e.age_range_min,
    e.age_range_max,
    e.allow_female,
    e.allow_male,
    e.allow_diverse,
    e.thumbnail,
    e.categories,
    COUNT(DISTINCT cm.message_id) as number_of_comments,
    COUNT(DISTINCT ea.user_id) as number_of_attendees
FROM events e
LEFT JOIN chat_messages cm ON e.event_id = cm.event_id
LEFT JOIN event_attendees ea ON e.event_id = ea.event_id
WHERE e.event_id = $1
GROUP BY 
    e.event_id,
    e.created_at,
    e.updated_at,
    e.creator_id,
    e.name,
    e.location,
    e.datetime,
    e.max_attendees,
    e.venue,
    e.description,
    e.status,
    e.age_range_min,
    e.age_range_max,
    e.allow_female,
    e.allow_male,
    e.allow_diverse,
    e.thumbnail,
    e.categories
`

type GetEventByIDRow struct {
	EventID           pgtype.UUID         `json:"event_id"`
	CreatedAt         pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz  `json:"updated_at"`
	CreatorID         pgtype.UUID         `json:"creator_id"`
	Name              string              `json:"name"`
	Latitude          interface{}         `json:"latitude"`
	Longitude         interface{}         `json:"longitude"`
	Datetime          pgtype.Timestamptz  `json:"datetime"`
	MaxAttendees      int32               `json:"max_attendees"`
	Venue             pgtype.Text         `json:"venue"`
	Description       pgtype.Text         `json:"description"`
	Status            EventStatusType     `json:"status"`
	AgeRangeMin       pgtype.Int4         `json:"age_range_min"`
	AgeRangeMax       pgtype.Int4         `json:"age_range_max"`
	AllowFemale       bool                `json:"allow_female"`
	AllowMale         bool                `json:"allow_male"`
	AllowDiverse      bool                `json:"allow_diverse"`
	Thumbnail         []byte              `json:"thumbnail"`
	Categories        []EventCategoryType `json:"categories"`
	NumberOfComments  int64               `json:"number_of_comments"`
	NumberOfAttendees int64               `json:"number_of_attendees"`
}

func (q *Queries) GetEventByID(ctx context.Context, eventID pgtype.UUID) (GetEventByIDRow, error) {
	row := q.db.QueryRow(ctx, getEventByID, eventID)
	var i GetEventByIDRow
	err := row.Scan(
		&i.EventID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatorID,
		&i.Name,
		&i.Latitude,
		&i.Longitude,
		&i.Datetime,
		&i.MaxAttendees,
		&i.Venue,
		&i.Description,
		&i.Status,
		&i.AgeRangeMin,
		&i.AgeRangeMax,
		&i.AllowFemale,
		&i.AllowMale,
		&i.AllowDiverse,
		&i.Thumbnail,
		&i.Categories,
		&i.NumberOfComments,
		&i.NumberOfAttendees,
	)
	return i, err
}

const getNearbyEventsByStatusAndGender = `-- name: GetNearbyEventsByStatusAndGender :many
SELECT 
    e.event_id,
    e.created_at,
    e.creator_id,
    e.name,
    ST_Y(e.location::geometry) as latitude,
    ST_X(e.location::geometry) as longitude,
    e.datetime,
    e.max_attendees,
    e.venue,
    e.status,
    e.age_range_min,
    e.age_range_max,
    e.allow_female,
    e.allow_male,
    e.allow_diverse,
    e.categories,
    ST_Distance(e.location, ST_SetSRID(ST_MakePoint($3, $2), 4326)) as distance_meters,
    COUNT(DISTINCT ea.user_id) as number_of_attendees
FROM events e
LEFT JOIN event_attendees ea ON e.event_id = ea.event_id
WHERE 
    e.status = $1 AND
    ST_DWithin(
        e.location,
        ST_SetSRID(ST_MakePoint($2, $3), 4326),
        $4  -- radius in meters
    ) AND
    CASE 
        WHEN $5 = 'female' THEN e.allow_female = true
        WHEN $5 = 'male' THEN e.allow_male = true
        WHEN $5 = 'diverse' THEN e.allow_diverse = true
    END
GROUP BY 
    e.event_id,
    e.created_at,
    e.creator_id,
    e.name,
    e.location,
    e.datetime,
    e.max_attendees,
    e.venue,
    e.status,
    e.age_range_min,
    e.age_range_max,
    e.allow_female,
    e.allow_male,
    e.allow_diverse,
    e.categories
ORDER BY distance_meters
LIMIT $6
`

type GetNearbyEventsByStatusAndGenderParams struct {
	Status        EventStatusType `json:"status"`
	StMakepoint   interface{}     `json:"st_makepoint"`
	StMakepoint_2 interface{}     `json:"st_makepoint_2"`
	StDwithin     interface{}     `json:"st_dwithin"`
	Column5       interface{}     `json:"column_5"`
	Limit         int32           `json:"limit"`
}

type GetNearbyEventsByStatusAndGenderRow struct {
	EventID           pgtype.UUID         `json:"event_id"`
	CreatedAt         pgtype.Timestamptz  `json:"created_at"`
	CreatorID         pgtype.UUID         `json:"creator_id"`
	Name              string              `json:"name"`
	Latitude          interface{}         `json:"latitude"`
	Longitude         interface{}         `json:"longitude"`
	Datetime          pgtype.Timestamptz  `json:"datetime"`
	MaxAttendees      int32               `json:"max_attendees"`
	Venue             pgtype.Text         `json:"venue"`
	Status            EventStatusType     `json:"status"`
	AgeRangeMin       pgtype.Int4         `json:"age_range_min"`
	AgeRangeMax       pgtype.Int4         `json:"age_range_max"`
	AllowFemale       bool                `json:"allow_female"`
	AllowMale         bool                `json:"allow_male"`
	AllowDiverse      bool                `json:"allow_diverse"`
	Categories        []EventCategoryType `json:"categories"`
	DistanceMeters    interface{}         `json:"distance_meters"`
	NumberOfAttendees int64               `json:"number_of_attendees"`
}

func (q *Queries) GetNearbyEventsByStatusAndGender(ctx context.Context, arg GetNearbyEventsByStatusAndGenderParams) ([]GetNearbyEventsByStatusAndGenderRow, error) {
	rows, err := q.db.Query(ctx, getNearbyEventsByStatusAndGender,
		arg.Status,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StDwithin,
		arg.Column5,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNearbyEventsByStatusAndGenderRow
	for rows.Next() {
		var i GetNearbyEventsByStatusAndGenderRow
		if err := rows.Scan(
			&i.EventID,
			&i.CreatedAt,
			&i.CreatorID,
			&i.Name,
			&i.Latitude,
			&i.Longitude,
			&i.Datetime,
			&i.MaxAttendees,
			&i.Venue,
			&i.Status,
			&i.AgeRangeMin,
			&i.AgeRangeMax,
			&i.AllowFemale,
			&i.AllowMale,
			&i.AllowDiverse,
			&i.Categories,
			&i.DistanceMeters,
			&i.NumberOfAttendees,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEvents = `-- name: GetUserEvents :many
SELECT 
    e.event_id, e.creator_id, e.created_at, e.updated_at, e.name, e.venue, e.description, e.categories, e.status, e.thumbnail, e.location, e.datetime, e.max_attendees, e.age_range_min, e.age_range_max, e.allow_female, e.allow_male, e.allow_diverse,
    ST_Y(e.location::geometry) as latitude,
    ST_X(e.location::geometry) as longitude,
    COUNT(DISTINCT ea.user_id) as number_of_attendees
FROM events e
JOIN event_attendees ea ON e.event_id = ea.event_id
WHERE ea.user_id = $1
GROUP BY 
    e.event_id,
    e.created_at,
    e.creator_id,
    e.name,
    e.location,
    e.datetime,
    e.max_attendees,
    e.venue,
    e.status,
    e.age_range_min,
    e.age_range_max,
    e.allow_female,
    e.allow_male,
    e.allow_diverse,
    e.categories
ORDER BY e.datetime DESC
LIMIT $2
`

type GetUserEventsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

type GetUserEventsRow struct {
	EventID           pgtype.UUID         `json:"event_id"`
	CreatorID         pgtype.UUID         `json:"creator_id"`
	CreatedAt         pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz  `json:"updated_at"`
	Name              string              `json:"name"`
	Venue             pgtype.Text         `json:"venue"`
	Description       pgtype.Text         `json:"description"`
	Categories        []EventCategoryType `json:"categories"`
	Status            EventStatusType     `json:"status"`
	Thumbnail         []byte              `json:"thumbnail"`
	Location          interface{}         `json:"location"`
	Datetime          pgtype.Timestamptz  `json:"datetime"`
	MaxAttendees      int32               `json:"max_attendees"`
	AgeRangeMin       pgtype.Int4         `json:"age_range_min"`
	AgeRangeMax       pgtype.Int4         `json:"age_range_max"`
	AllowFemale       bool                `json:"allow_female"`
	AllowMale         bool                `json:"allow_male"`
	AllowDiverse      bool                `json:"allow_diverse"`
	Latitude          interface{}         `json:"latitude"`
	Longitude         interface{}         `json:"longitude"`
	NumberOfAttendees int64               `json:"number_of_attendees"`
}

func (q *Queries) GetUserEvents(ctx context.Context, arg GetUserEventsParams) ([]GetUserEventsRow, error) {
	rows, err := q.db.Query(ctx, getUserEvents, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserEventsRow
	for rows.Next() {
		var i GetUserEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.CreatorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Venue,
			&i.Description,
			&i.Categories,
			&i.Status,
			&i.Thumbnail,
			&i.Location,
			&i.Datetime,
			&i.MaxAttendees,
			&i.AgeRangeMin,
			&i.AgeRangeMax,
			&i.AllowFemale,
			&i.AllowMale,
			&i.AllowDiverse,
			&i.Latitude,
			&i.Longitude,
			&i.NumberOfAttendees,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const joinEvent = `-- name: JoinEvent :exec
INSERT INTO event_attendees (event_id, user_id, gender)
SELECT $1, $2, u.gender
FROM users u
JOIN events e ON e.event_id = $1
WHERE u.user_id = $2
AND EXTRACT(YEAR FROM AGE(e.datetime, u.birthday)) BETWEEN e.age_range_min AND e.age_range_max
AND NOT EXISTS (
    SELECT 1 FROM event_attendees 
    WHERE event_id = $1 AND user_id = $2
)
`

type JoinEventParams struct {
	EventID pgtype.UUID `json:"event_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

func (q *Queries) JoinEvent(ctx context.Context, arg JoinEventParams) error {
	_, err := q.db.Exec(ctx, joinEvent, arg.EventID, arg.UserID)
	return err
}

const leaveEvent = `-- name: LeaveEvent :exec
DELETE FROM event_attendees
WHERE event_id = $1 AND user_id = $2
`

type LeaveEventParams struct {
	EventID pgtype.UUID `json:"event_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

func (q *Queries) LeaveEvent(ctx context.Context, arg LeaveEventParams) error {
	_, err := q.db.Exec(ctx, leaveEvent, arg.EventID, arg.UserID)
	return err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
SET updated_at = NOW(), status = $2, name = $3, location = ST_SetSRID(ST_MakePoint($5, $4), 4326),
    datetime = $6, max_attendees = $7, venue = $8, description = $9, 
    age_range_min = $10, age_range_max = $11, allow_male = $12, allow_female = $13, allow_diverse = $14,
    categories = $15
WHERE event_id = $1
RETURNING 
    event_id,
    created_at,
    updated_at,
    creator_id,
    name,
    ST_Y(location::geometry) as latitude,
    ST_X(location::geometry) as longitude,
    datetime,
    max_attendees,
    venue,
    description,
    status,
    age_range_min,
    age_range_max,
    allow_female,
    allow_male,
    allow_diverse,
    categories
`

type UpdateEventParams struct {
	EventID       pgtype.UUID         `json:"event_id"`
	Status        EventStatusType     `json:"status"`
	Name          string              `json:"name"`
	StMakepoint   interface{}         `json:"st_makepoint"`
	StMakepoint_2 interface{}         `json:"st_makepoint_2"`
	Datetime      pgtype.Timestamptz  `json:"datetime"`
	MaxAttendees  int32               `json:"max_attendees"`
	Venue         pgtype.Text         `json:"venue"`
	Description   pgtype.Text         `json:"description"`
	AgeRangeMin   pgtype.Int4         `json:"age_range_min"`
	AgeRangeMax   pgtype.Int4         `json:"age_range_max"`
	AllowMale     bool                `json:"allow_male"`
	AllowFemale   bool                `json:"allow_female"`
	AllowDiverse  bool                `json:"allow_diverse"`
	Categories    []EventCategoryType `json:"categories"`
}

type UpdateEventRow struct {
	EventID      pgtype.UUID         `json:"event_id"`
	CreatedAt    pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz  `json:"updated_at"`
	CreatorID    pgtype.UUID         `json:"creator_id"`
	Name         string              `json:"name"`
	Latitude     interface{}         `json:"latitude"`
	Longitude    interface{}         `json:"longitude"`
	Datetime     pgtype.Timestamptz  `json:"datetime"`
	MaxAttendees int32               `json:"max_attendees"`
	Venue        pgtype.Text         `json:"venue"`
	Description  pgtype.Text         `json:"description"`
	Status       EventStatusType     `json:"status"`
	AgeRangeMin  pgtype.Int4         `json:"age_range_min"`
	AgeRangeMax  pgtype.Int4         `json:"age_range_max"`
	AllowFemale  bool                `json:"allow_female"`
	AllowMale    bool                `json:"allow_male"`
	AllowDiverse bool                `json:"allow_diverse"`
	Categories   []EventCategoryType `json:"categories"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (UpdateEventRow, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.EventID,
		arg.Status,
		arg.Name,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.Datetime,
		arg.MaxAttendees,
		arg.Venue,
		arg.Description,
		arg.AgeRangeMin,
		arg.AgeRangeMax,
		arg.AllowMale,
		arg.AllowFemale,
		arg.AllowDiverse,
		arg.Categories,
	)
	var i UpdateEventRow
	err := row.Scan(
		&i.EventID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatorID,
		&i.Name,
		&i.Latitude,
		&i.Longitude,
		&i.Datetime,
		&i.MaxAttendees,
		&i.Venue,
		&i.Description,
		&i.Status,
		&i.AgeRangeMin,
		&i.AgeRangeMax,
		&i.AllowFemale,
		&i.AllowMale,
		&i.AllowDiverse,
		&i.Categories,
	)
	return i, err
}
