// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: events.sql

package sqlc

import (
	"context"

	"github.com/cridenour/go-postgis"
	"github.com/jackc/pgx/v5/pgtype"
)

const addEventCategory = `-- name: AddEventCategory :exec
INSERT INTO event_categories (event_id, category)
VALUES ($1, $2)
`

type AddEventCategoryParams struct {
	EventID  pgtype.UUID       `json:"event_id"`
	Category EventCategoryType `json:"category"`
}

func (q *Queries) AddEventCategory(ctx context.Context, arg AddEventCategoryParams) error {
	_, err := q.db.Exec(ctx, addEventCategory, arg.EventID, arg.Category)
	return err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    creator_id, name, location, event_datetime, 
    timezone_offset_minutes, max_attendees, venue, 
    description, age_range_min, age_range_max,
    allow_female, allow_male, allow_diverse
)
VALUES (
    $1, $2, ST_SetSRID(ST_MakePoint($3, $4), 4326), $5, 
    $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING event_id, creator_id, name, location, event_datetime, timezone_offset_minutes, max_attendees, venue, description, thumbnail, status, age_range_min, age_range_max, allow_female, allow_male, allow_diverse, created_at
`

type CreateEventParams struct {
	CreatorID             pgtype.UUID        `json:"creator_id"`
	Name                  string             `json:"name"`
	StMakepoint           interface{}        `json:"st_makepoint"`
	StMakepoint_2         interface{}        `json:"st_makepoint_2"`
	EventDatetime         pgtype.Timestamptz `json:"event_datetime"`
	TimezoneOffsetMinutes int32              `json:"timezone_offset_minutes"`
	MaxAttendees          int32              `json:"max_attendees"`
	Venue                 pgtype.Text        `json:"venue"`
	Description           pgtype.Text        `json:"description"`
	AgeRangeMin           pgtype.Int4        `json:"age_range_min"`
	AgeRangeMax           pgtype.Int4        `json:"age_range_max"`
	AllowFemale           bool               `json:"allow_female"`
	AllowMale             bool               `json:"allow_male"`
	AllowDiverse          bool               `json:"allow_diverse"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.CreatorID,
		arg.Name,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.EventDatetime,
		arg.TimezoneOffsetMinutes,
		arg.MaxAttendees,
		arg.Venue,
		arg.Description,
		arg.AgeRangeMin,
		arg.AgeRangeMax,
		arg.AllowFemale,
		arg.AllowMale,
		arg.AllowDiverse,
	)
	var i Event
	err := row.Scan(
		&i.EventID,
		&i.CreatorID,
		&i.Name,
		&i.Location,
		&i.EventDatetime,
		&i.TimezoneOffsetMinutes,
		&i.MaxAttendees,
		&i.Venue,
		&i.Description,
		&i.Thumbnail,
		&i.Status,
		&i.AgeRangeMin,
		&i.AgeRangeMax,
		&i.AllowFemale,
		&i.AllowMale,
		&i.AllowDiverse,
		&i.CreatedAt,
	)
	return i, err
}

const getEventAttendeeStats = `-- name: GetEventAttendeeStats :one
SELECT 
    COUNT(CASE WHEN gender = 'female' THEN 1 END) as female_count,
    COUNT(CASE WHEN gender = 'male' THEN 1 END) as male_count,
    COUNT(CASE WHEN gender = 'diverse' THEN 1 END) as diverse_count
FROM event_attendees
WHERE event_id = $1
`

type GetEventAttendeeStatsRow struct {
	FemaleCount  int64 `json:"female_count"`
	MaleCount    int64 `json:"male_count"`
	DiverseCount int64 `json:"diverse_count"`
}

func (q *Queries) GetEventAttendeeStats(ctx context.Context, eventID pgtype.UUID) (GetEventAttendeeStatsRow, error) {
	row := q.db.QueryRow(ctx, getEventAttendeeStats, eventID)
	var i GetEventAttendeeStatsRow
	err := row.Scan(&i.FemaleCount, &i.MaleCount, &i.DiverseCount)
	return i, err
}

const getEventByID = `-- name: GetEventByID :one
SELECT 
    e.event_id, e.creator_id, e.name, e.location, e.event_datetime, e.timezone_offset_minutes, e.max_attendees, e.venue, e.description, e.thumbnail, e.status, e.age_range_min, e.age_range_max, e.allow_female, e.allow_male, e.allow_diverse, e.created_at,
    json_agg(DISTINCT ec.category) as categories,
    COUNT(DISTINCT cm.message_id) as number_of_comments,
    COUNT(DISTINCT ea.user_id) as number_of_attendees
FROM events e
LEFT JOIN event_categories ec ON e.event_id = ec.event_id
LEFT JOIN chat_messages cm ON e.event_id = cm.event_id
LEFT JOIN event_attendees ea ON e.event_id = ea.event_id
WHERE e.event_id = $1
GROUP BY e.event_id
`

type GetEventByIDRow struct {
	EventID               pgtype.UUID         `json:"event_id"`
	CreatorID             pgtype.UUID         `json:"creator_id"`
	Name                  string              `json:"name"`
	Location              postgis.Point       `json:"location"`
	EventDatetime         pgtype.Timestamptz  `json:"event_datetime"`
	TimezoneOffsetMinutes int32               `json:"timezone_offset_minutes"`
	MaxAttendees          int32               `json:"max_attendees"`
	Venue                 pgtype.Text         `json:"venue"`
	Description           pgtype.Text         `json:"description"`
	Thumbnail             []byte              `json:"thumbnail"`
	Status                NullEventStatusType `json:"status"`
	AgeRangeMin           pgtype.Int4         `json:"age_range_min"`
	AgeRangeMax           pgtype.Int4         `json:"age_range_max"`
	AllowFemale           bool                `json:"allow_female"`
	AllowMale             bool                `json:"allow_male"`
	AllowDiverse          bool                `json:"allow_diverse"`
	CreatedAt             pgtype.Timestamptz  `json:"created_at"`
	Categories            []byte              `json:"categories"`
	NumberOfComments      int64               `json:"number_of_comments"`
	NumberOfAttendees     int64               `json:"number_of_attendees"`
}

func (q *Queries) GetEventByID(ctx context.Context, eventID pgtype.UUID) (GetEventByIDRow, error) {
	row := q.db.QueryRow(ctx, getEventByID, eventID)
	var i GetEventByIDRow
	err := row.Scan(
		&i.EventID,
		&i.CreatorID,
		&i.Name,
		&i.Location,
		&i.EventDatetime,
		&i.TimezoneOffsetMinutes,
		&i.MaxAttendees,
		&i.Venue,
		&i.Description,
		&i.Thumbnail,
		&i.Status,
		&i.AgeRangeMin,
		&i.AgeRangeMax,
		&i.AllowFemale,
		&i.AllowMale,
		&i.AllowDiverse,
		&i.CreatedAt,
		&i.Categories,
		&i.NumberOfComments,
		&i.NumberOfAttendees,
	)
	return i, err
}

const getNearbyEvents = `-- name: GetNearbyEvents :many
SELECT 
    event_id,
    creator_id,
    name,
    location,
    event_datetime,
    timezone_offset_minutes,
    max_attendees,
    venue,
    status,
    age_range_min,
    age_range_max,
    allow_female,
    allow_male,
    allow_diverse,
    created_at,
    ST_Distance(location, ST_SetSRID(ST_MakePoint($1, $2), 4326)) as distance_meters
FROM events
WHERE 
    status = 'upcoming' AND
    ST_DWithin(
        location,
        ST_SetSRID(ST_MakePoint($1, $2), 4326),
        $3  -- radius in meters
    )
ORDER BY distance_meters
LIMIT $4
`

type GetNearbyEventsParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	StDwithin     interface{} `json:"st_dwithin"`
	Limit         int32       `json:"limit"`
}

type GetNearbyEventsRow struct {
	EventID               pgtype.UUID         `json:"event_id"`
	CreatorID             pgtype.UUID         `json:"creator_id"`
	Name                  string              `json:"name"`
	Location              postgis.Point       `json:"location"`
	EventDatetime         pgtype.Timestamptz  `json:"event_datetime"`
	TimezoneOffsetMinutes int32               `json:"timezone_offset_minutes"`
	MaxAttendees          int32               `json:"max_attendees"`
	Venue                 pgtype.Text         `json:"venue"`
	Status                NullEventStatusType `json:"status"`
	AgeRangeMin           pgtype.Int4         `json:"age_range_min"`
	AgeRangeMax           pgtype.Int4         `json:"age_range_max"`
	AllowFemale           bool                `json:"allow_female"`
	AllowMale             bool                `json:"allow_male"`
	AllowDiverse          bool                `json:"allow_diverse"`
	CreatedAt             pgtype.Timestamptz  `json:"created_at"`
	DistanceMeters        interface{}         `json:"distance_meters"`
}

func (q *Queries) GetNearbyEvents(ctx context.Context, arg GetNearbyEventsParams) ([]GetNearbyEventsRow, error) {
	rows, err := q.db.Query(ctx, getNearbyEvents,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StDwithin,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNearbyEventsRow
	for rows.Next() {
		var i GetNearbyEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.CreatorID,
			&i.Name,
			&i.Location,
			&i.EventDatetime,
			&i.TimezoneOffsetMinutes,
			&i.MaxAttendees,
			&i.Venue,
			&i.Status,
			&i.AgeRangeMin,
			&i.AgeRangeMax,
			&i.AllowFemale,
			&i.AllowMale,
			&i.AllowDiverse,
			&i.CreatedAt,
			&i.DistanceMeters,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEvents = `-- name: GetUserEvents :many
SELECT e.event_id, e.creator_id, e.name, e.location, e.event_datetime, e.timezone_offset_minutes, e.max_attendees, e.venue, e.description, e.thumbnail, e.status, e.age_range_min, e.age_range_max, e.allow_female, e.allow_male, e.allow_diverse, e.created_at
FROM events e
JOIN event_attendees ea ON e.event_id = ea.event_id
WHERE ea.user_id = $1
ORDER BY e.event_datetime DESC
`

func (q *Queries) GetUserEvents(ctx context.Context, userID pgtype.UUID) ([]Event, error) {
	rows, err := q.db.Query(ctx, getUserEvents, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.CreatorID,
			&i.Name,
			&i.Location,
			&i.EventDatetime,
			&i.TimezoneOffsetMinutes,
			&i.MaxAttendees,
			&i.Venue,
			&i.Description,
			&i.Thumbnail,
			&i.Status,
			&i.AgeRangeMin,
			&i.AgeRangeMax,
			&i.AllowFemale,
			&i.AllowMale,
			&i.AllowDiverse,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const joinEvent = `-- name: JoinEvent :exec
INSERT INTO event_attendees (event_id, user_id, gender)
SELECT $1, $2, users.gender
FROM users
WHERE users.user_id = $2
AND NOT EXISTS (
    SELECT 1 FROM event_attendees 
    WHERE event_id = $1 AND user_id = $2
)
`

type JoinEventParams struct {
	EventID pgtype.UUID `json:"event_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

func (q *Queries) JoinEvent(ctx context.Context, arg JoinEventParams) error {
	_, err := q.db.Exec(ctx, joinEvent, arg.EventID, arg.UserID)
	return err
}

const leaveEvent = `-- name: LeaveEvent :exec
DELETE FROM event_attendees
WHERE event_id = $1 AND user_id = $2
`

type LeaveEventParams struct {
	EventID pgtype.UUID `json:"event_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

func (q *Queries) LeaveEvent(ctx context.Context, arg LeaveEventParams) error {
	_, err := q.db.Exec(ctx, leaveEvent, arg.EventID, arg.UserID)
	return err
}

const searchEvents = `-- name: SearchEvents :many
SELECT 
    e.event_id, e.creator_id, e.name, e.location, e.event_datetime, e.timezone_offset_minutes, e.max_attendees, e.venue, e.description, e.thumbnail, e.status, e.age_range_min, e.age_range_max, e.allow_female, e.allow_male, e.allow_diverse, e.created_at,
    json_agg(DISTINCT ec.category) as categories
FROM events e
LEFT JOIN event_categories ec ON e.event_id = ec.event_id
WHERE 
    (LOWER(e.name) LIKE LOWER($1) OR LOWER(e.description) LIKE LOWER($1))
    AND (status = 'upcoming' OR status = 'ongoing')
GROUP BY e.event_id
ORDER BY event_datetime
LIMIT $2 OFFSET $3
`

type SearchEventsParams struct {
	Lower  string `json:"lower"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type SearchEventsRow struct {
	EventID               pgtype.UUID         `json:"event_id"`
	CreatorID             pgtype.UUID         `json:"creator_id"`
	Name                  string              `json:"name"`
	Location              postgis.Point       `json:"location"`
	EventDatetime         pgtype.Timestamptz  `json:"event_datetime"`
	TimezoneOffsetMinutes int32               `json:"timezone_offset_minutes"`
	MaxAttendees          int32               `json:"max_attendees"`
	Venue                 pgtype.Text         `json:"venue"`
	Description           pgtype.Text         `json:"description"`
	Thumbnail             []byte              `json:"thumbnail"`
	Status                NullEventStatusType `json:"status"`
	AgeRangeMin           pgtype.Int4         `json:"age_range_min"`
	AgeRangeMax           pgtype.Int4         `json:"age_range_max"`
	AllowFemale           bool                `json:"allow_female"`
	AllowMale             bool                `json:"allow_male"`
	AllowDiverse          bool                `json:"allow_diverse"`
	CreatedAt             pgtype.Timestamptz  `json:"created_at"`
	Categories            []byte              `json:"categories"`
}

func (q *Queries) SearchEvents(ctx context.Context, arg SearchEventsParams) ([]SearchEventsRow, error) {
	rows, err := q.db.Query(ctx, searchEvents, arg.Lower, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchEventsRow
	for rows.Next() {
		var i SearchEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.CreatorID,
			&i.Name,
			&i.Location,
			&i.EventDatetime,
			&i.TimezoneOffsetMinutes,
			&i.MaxAttendees,
			&i.Venue,
			&i.Description,
			&i.Thumbnail,
			&i.Status,
			&i.AgeRangeMin,
			&i.AgeRangeMax,
			&i.AllowFemale,
			&i.AllowMale,
			&i.AllowDiverse,
			&i.CreatedAt,
			&i.Categories,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventStatus = `-- name: UpdateEventStatus :one
UPDATE events
SET status = $2
WHERE event_id = $1
RETURNING event_id, creator_id, name, location, event_datetime, timezone_offset_minutes, max_attendees, venue, description, thumbnail, status, age_range_min, age_range_max, allow_female, allow_male, allow_diverse, created_at
`

type UpdateEventStatusParams struct {
	EventID pgtype.UUID         `json:"event_id"`
	Status  NullEventStatusType `json:"status"`
}

func (q *Queries) UpdateEventStatus(ctx context.Context, arg UpdateEventStatusParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEventStatus, arg.EventID, arg.Status)
	var i Event
	err := row.Scan(
		&i.EventID,
		&i.CreatorID,
		&i.Name,
		&i.Location,
		&i.EventDatetime,
		&i.TimezoneOffsetMinutes,
		&i.MaxAttendees,
		&i.Venue,
		&i.Description,
		&i.Thumbnail,
		&i.Status,
		&i.AgeRangeMin,
		&i.AgeRangeMax,
		&i.AllowFemale,
		&i.AllowMale,
		&i.AllowDiverse,
		&i.CreatedAt,
	)
	return i, err
}
