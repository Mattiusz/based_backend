// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: chat.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages (event_id, user_id, content, edited_at, type, status)
VALUES ($1, $2, $3, NOW(), $4, 'sent')
RETURNING message_id, event_id, user_id, content, type, status, created_at, edited_at
`

type CreateChatMessageParams struct {
	EventID pgtype.UUID `json:"event_id"`
	UserID  pgtype.UUID `json:"user_id"`
	Content string      `json:"content"`
	Type    MessageType `json:"type"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.EventID,
		arg.UserID,
		arg.Content,
		arg.Type,
	)
	var i ChatMessage
	err := row.Scan(
		&i.MessageID,
		&i.EventID,
		&i.UserID,
		&i.Content,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.EditedAt,
	)
	return i, err
}

const deleteChatMessage = `-- name: DeleteChatMessage :exec
DELETE FROM chat_messages
WHERE message_id = $1
AND user_id = $2
`

type DeleteChatMessageParams struct {
	MessageID pgtype.UUID `json:"message_id"`
	UserID    pgtype.UUID `json:"user_id"`
}

// Note: This will cascade delete all message likes
func (q *Queries) DeleteChatMessage(ctx context.Context, arg DeleteChatMessageParams) error {
	_, err := q.db.Exec(ctx, deleteChatMessage, arg.MessageID, arg.UserID)
	return err
}

const getEventMessages = `-- name: GetEventMessages :many
SELECT 
    cm.message_id, cm.event_id, cm.user_id, cm.content, cm.type, cm.status, cm.created_at, cm.edited_at,
    COUNT(ml.user_id) as number_of_likes,
    EXISTS(
        SELECT 1 FROM message_likes 
        WHERE message_id = cm.message_id AND message_likes.user_id = $2
    ) as is_liked_by_user
FROM chat_messages cm
LEFT JOIN message_likes ml ON cm.message_id = ml.message_id
WHERE cm.event_id = $1
GROUP BY cm.message_id
ORDER BY cm.created_at
`

type GetEventMessagesParams struct {
	EventID pgtype.UUID `json:"event_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

type GetEventMessagesRow struct {
	MessageID     pgtype.UUID        `json:"message_id"`
	EventID       pgtype.UUID        `json:"event_id"`
	UserID        pgtype.UUID        `json:"user_id"`
	Content       string             `json:"content"`
	Type          MessageType        `json:"type"`
	Status        MessageStatusType  `json:"status"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	EditedAt      pgtype.Timestamptz `json:"edited_at"`
	NumberOfLikes int64              `json:"number_of_likes"`
	IsLikedByUser bool               `json:"is_liked_by_user"`
}

func (q *Queries) GetEventMessages(ctx context.Context, arg GetEventMessagesParams) ([]GetEventMessagesRow, error) {
	rows, err := q.db.Query(ctx, getEventMessages, arg.EventID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventMessagesRow
	for rows.Next() {
		var i GetEventMessagesRow
		if err := rows.Scan(
			&i.MessageID,
			&i.EventID,
			&i.UserID,
			&i.Content,
			&i.Type,
			&i.Status,
			&i.CreatedAt,
			&i.EditedAt,
			&i.NumberOfLikes,
			&i.IsLikedByUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const likeMessage = `-- name: LikeMessage :exec
INSERT INTO message_likes (message_id, user_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type LikeMessageParams struct {
	MessageID pgtype.UUID `json:"message_id"`
	UserID    pgtype.UUID `json:"user_id"`
}

func (q *Queries) LikeMessage(ctx context.Context, arg LikeMessageParams) error {
	_, err := q.db.Exec(ctx, likeMessage, arg.MessageID, arg.UserID)
	return err
}

const unlikeMessage = `-- name: UnlikeMessage :exec
DELETE FROM message_likes
WHERE message_id = $1 AND user_id = $2
`

type UnlikeMessageParams struct {
	MessageID pgtype.UUID `json:"message_id"`
	UserID    pgtype.UUID `json:"user_id"`
}

func (q *Queries) UnlikeMessage(ctx context.Context, arg UnlikeMessageParams) error {
	_, err := q.db.Exec(ctx, unlikeMessage, arg.MessageID, arg.UserID)
	return err
}
